\documentclass{acm_proc_article-sp}
\begin{document}

\title{ICS-OS: A Kernel Programming Approach to Teaching Operating System
Concepts\titlenote{ICS-OS is an open source project available at
http://code.google.com/p/ics-os/}}

\numberofauthors{1}
\author{
\alignauthor
Joseph Anthony C. Hermocilla\\
       \affaddr{Institute of Computer Science}\\
       \affaddr{College of Arts and Sciences}\\
       \affaddr{University of the Philippines Los Ba\~nos}\\
       \affaddr{College 4031, Laguna, Philippines}\\
       \email{jachermocilla@uplb.edu.ph}
}
\date{02 September 2009}

\maketitle
\begin{abstract}
Traditional approaches to teaching operating systems require students to
develop simulations and user space applications. An alternative
is to let them modify parts of an actual operating system and see their
programs run at kernel space. However, this is difficult to 
achieve using modern real-world operating systems partly because of the complex
and large source code base. This paper presents ICS-OS and the experiences and
results of using it for teaching an undergraduate operating systems course. 
ICS-OS is based on the DEX-OS kernel which has a smaller source code base
compared to other operating systems, making it ideal for instruction. 
The students were able to demonstrate a deeper understanding
of how a real operating system works by their succesful implementation of
projects to enhance and extend ICS-OS.
\end{abstract}

\category{D.4.7}{Operating Systems}{Organization and Design}
\category{K.3.2}{Computer and Information Science Education}
{Computer Science Education}

\keywords{Operating systems, computer science education, kernel} 

\section{Introduction}
Operating systems is a fundamental knowledge area in computer science education
emphasized by the ACM and IEEE review task force for the computer science 
curriculum. Traditional approaches to teaching operating systems to 
undergraduates, as in the case at the author's institution, do not involve 
programming the components of an actual operating system that can run on 
real hardware. Instead, simulations are used or user space application 
development are done. Students, however, are more interested in writing code
that runs at the kernel space, internal to the operating system itself. They
want to concretize the abstract concepts in operating systems through kernel
code. To achieve this, either the students can build an operating system from
scratch or modify an existing one.

Building an operating system from scratch is not the best option since a course
is usually offered for a semester and there is not enough time to finish. In 
addition, the prerequisite knowledge needed to make an operating system may have
not been acquired by the students yet. To write an operating system from 
scratch, one has to have knowledge of the processor architecture, assembly
language, data structures, algorithms, and low-level C programming.

Modifying an actual operating system that runs on real hardware is a more
viable alternative. However, the choice of the operating system to use is
still an issue. In the past, several instructional operating systems have been
proposed and developed. The next section briefly reviews some of them 
to highlight their strengths and weaknesses.

Two criteria for choosing the operating system to use are completeness 
and size of the source code base. An instructional operating system that does
not implement high level abstractions like process management, memory 
management, and filesystems will unlikely be a good choice because
of the missing features. On the other hand, an operating system with several 
thousands of lines of code and a complicated source directory structure will
confuse students and will take more time to understand. Thus there should
be a right balance between completeness and code size.

Recent developments in hardware emulation and virtualization has also made it 
easier to work with real-world operating systems. Testing a kernel need not
require a reboot of the development machine for testing. Unnecessary 
boostrapping is no longer needed since the test machine is a software
application running on the development machine itself.
 
The delivery of an operating systems course is usually through a lecture and 
a laboratory component. A popular textbook used by instructors in the 
lecture is the dinosaur book by Silberschatz and Galvin \cite{silberschatz:osc}.
Though students find the concepts interesting, they still want to see these
concepts implemented at the source code level in an actual operating system.

\cite{silberschatz:osc},\cite{tanenbaum:osdai},\cite{dayo:dexos},
\cite{claypool:fossil},\cite{christopher:nachos},\cite{gary:nachos},
\cite{tanenbaum:minix},\cite{black:osfs},\cite{hovemeyer:geekos},
\cite{anderson:survey}


\section{Related Work}

\subsection{Minix}
Minix has been around for several years already and has been the running 
example in the textbook, Operating Systems: Design and Implementation by 
Andrew Tanenbaum. Since its initial release, Minix has grown in size in terms
of source code as well as in complexity. 

\subsection{Nachos}
Nachos is instructional software for teaching undergraduate, and potentially
graduate, level operating systems courses. The Nachos distribution
comes with: 

   an overview paper
   simple baseline code for a working operating system
   a simulator for a generic personal computer/workstation
   sample assignments
   a C++ primer (Nachos is written in an easy-to-learn subset of C++, 
     and the primer helps teach C programmers our subset)

The assignments illustrate and explore all areas of modern operating
systems, including threads and concurrency, multiprogramming, 
system calls, virtual memory, software-loaded TLB's, file systems, 
network protocols, remote procedure call, and distributed systems.


\subsection{GeekOS}

GeekOS is another instructional operating system that runs on real hardware. 
It was developed by David Hovemeyer and used for instruction at the Department 
of Computer Science, University of Maryland. The design goals for GeekOS are
simplicity, realism, and understandability. The main features of GeekOS include interrupt handling, heap memory allocator, time-sliced kernel threads with 
static priority scheduling, mutexes and condition variables, user mode 
with segmentation-based memory protection, and device drivers for keyboard 
and VGA.


\subsection{Dex-OS}
Dex-OS was developed by Joseph Emmanuel Dayo. Dex-OS was opensourced under 
the GPL with the original project hosted at SourceForge. Its design is based on
an Aspect Oriented Approach to address cross-cutting concerns in operating 
systems design and implementation. A layered approach was taken based on 
modern operating systems like linux and windows. The following are the main
components of DEX-OS.

\textit{Memory Manager}

The memory manager is responsible for allocating memory to various components
of the operating system, including processes. It is further divided into 
low-level memory manager for setting up the GDT and high-level memory manager
for high-level functions such as malloc() and free().

\textit{Device Manager}

The device manager handles operations related to common devices and peripherals.
Device drivers for keyboard, display, and disk drives are managed by this 
module. Each device being managed is identified by a device id. 

\textit{Process Manager}

The process manager is responsible for handling process management functions
including process creation, process dispatching, process scheduling, process
synchronization, and process termination. 

\textit{Virtual Filesystem}

The Virtual File System (VFS) provides an device-independent abstraction for
various directory and file operations. Functions that are part of the VFS are
implemented by the low-level file system drivers. In particular, DEX-OS 
supports the Microsoft FAT12, FAT16, and FAT32 file systems.

\section{Methodology}

\subsection{Setup a linux development environment}
The original development environment for DEX-OS was in Windows and uses the 
Dev-C++ IDE. Since the laboratory rooms of the students were classes are held
use linux, the first step was to migrate the development environment to 
linux. The following steps were taken.

The Makefile is the primary mechanism to build the ICS-OS kernel and 
generate a distribution floppy. The original Makefile and Linker Script
was converted to generate an ELF kernel image (linux) instead of COFF.


\section{Results and Discussion}

\section{Conclusion}

\bibliographystyle{abbrv}
\bibliography{jach-ncite09.bib}
\balancecolumns


\end{document}
